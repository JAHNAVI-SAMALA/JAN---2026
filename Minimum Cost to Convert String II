class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        from collections import defaultdict
        
        INF = 10**18
        n = len(source)
        
        by_len = defaultdict(list)
        for o, c, w in zip(original, changed, cost):
            by_len[len(o)].append((o, c, w))
        
        conv = {}
        
        for L, rules in by_len.items():
            idx = {}
            k = 0
            for o, c, _ in rules:
                if o not in idx:
                    idx[o] = k; k += 1
                if c not in idx:
                    idx[c] = k; k += 1
            
            dist = [[INF]*k for _ in range(k)]
            for i in range(k):
                dist[i][i] = 0
            
            for o, c, w in rules:
                dist[idx[o]][idx[c]] = min(dist[idx[o]][idx[c]], w)
            
            for m in range(k):
                for i in range(k):
                    for j in range(k):
                        if dist[i][m] + dist[m][j] < dist[i][j]:
                            dist[i][j] = dist[i][m] + dist[m][j]
            
            conv[L] = (idx, dist)
        
        dp = [INF] * (n + 1)
        dp[n] = 0
        
        for i in range(n - 1, -1, -1):
            if source[i] == target[i]:
                dp[i] = dp[i + 1]
            
            for L, (idx, dist) in conv.items():
                if i + L <= n:
                    s = source[i:i+L]
                    t = target[i:i+L]
                    if s in idx and t in idx:
                        d = dist[idx[s]][idx[t]]
                        if d < INF:
                            dp[i] = min(dp[i], d + dp[i + L])
        
        return -1 if dp[0] == INF else dp[0]
